#+TITLE: April 2017 Articles

* TODO [[http://phrack.org/issues/60/10.html][Basic Integer Overflows]]                                       :secdev:
* TODO [[https://crypto.stanford.edu/cs155/papers/formatstring-1.2.pdf][Exploiting Format String Vulnerabilities]]             :secdev:format:c:
* TODO [[http://insecure.org/stf/smashstack.html][Smashing the stack for Fun and Profit]]          :secdev:classic:buffer:
* TODO [[https://arstechnica.com/security/2015/08/how-security-flaws-work-the-buffer-overflow/][How security flaws work: The Buffer Overflow]]           :secdev:buffer:
* DONE [[https://security.web.cern.ch/security/recommendations/en/codetools/c.shtml][Common Vulnerabilities in C]]                                 :secdev:c:
  CLOSED: [2017-04-10 Mon 00:36]
  - =gets= does not check buffer length (duh)
    - Use fgets and *dynamic* memory. 
  - =strcpy= just don't use it, or it's family of functions, e.g strcat
    - Prefer strlcpy if it's available.
      #+begin_src
      #include <stdio.h>
 
      // snprintf with %s guarantees \0 termination
      #ifndef strlcpy
      #define strlcpy(dst,src,sz) snprintf((dst), (sz), "%s", (src))
      #endif
 
      enum { BUFFER_SIZE = 10 };
 
      int main() {
        char dst[BUFFER_SIZE];
        char src[] = "abcdefghijk";
 
        int buffer_length = strlcpy(dst, src, BUFFER_SIZE);
 
        if (buffer_length >= BUFFER_SIZE) {
           printf external link("String too long: %d (%d expected)\n",
                buffer_length, BUFFER_SIZE-1);
         }
 
         printf external link("String copied: %s\n", dst);
 
        return 0;
      }
      #+end_src
   - Can use =strncpy=, but less convenient as it doesn't do \0 termination.
   - Don't use sprintf. Prefer snprintf
   - For printf family. ALWAYS hardcode the format string.
   - Opening files
     - Symbolic link attack
       - Potential race between checking if file exists, and call to `fopen` 
          #+begin_src
          #include <stdio.h>
          #include <stdlib.h>
          #include <unistd.h>
           
          #define MY_TMP_FILE "/tmp/file.tmp"
           
           
          int main(int argc, char* argv[])
          {
              FILE * f;
              if (!access(MY_TMP_FILE, F_OK)) {
                  printf external link("File exists!\n");
                  return EXIT_FAILURE;
              }
              /* At this point the attacker creates a symlink from /tmp/file.tmp to /etc/passwd */
              tmpFile = fopen(MY_TMP_FILE, "w");
           
              if (tmpFile == NULL) {
                  return EXIT_FAILURE;
              }
           
              fputs("Some text...\n", tmpFile);
           
              fclose(tmpFile);
              /* You successfully overwrote /etc/passwd (at least if you ran this as root) */
           
              return EXIT_SUCCESS;
          }
          #+end_src
        - Mitigation: Avoid race by accessing directly the file, and don't overwrite if it already exists
          #+begin_src
          #include <unistd.h>
          #include <stdio.h>
          #include <fcntl.h>
          #include <stdlib.h>
           
          #define MY_TMP_FILE "/tmp/file.tmp"
           
          enum { FILE_MODE = 0600 };
           
          int main(int argc, char* argv[])
          {
              int fd;
              FILE* f;
           
              /* Remove possible symlinks */
              unlink(MY_TMP_FILE);
              /* Open, but fail if someone raced us and restored the symlink (secure version of fopen(path, "w") */
              fd = open(MY_TMP_FILE, O_WRONLY|O_CREAT|O_EXCL, FILE_MODE);
              if (fd == -1) {
                  perror("Failed to open the file");
                  return EXIT_FAILURE;
              }
              /* Get a FILE*, as they are easier and more efficient than plan file descriptors */
              f = fdopen(fd, "w");
              if (f == NULL) {
                  perror("Failed to associate file descriptor with a stream");
                  return EXIT_FAILURE;
              }
              fprintf(f, "Hello, world\n");
              fclose(f);
              /* fd is already closed by fclose()!!! */
              return EXIT_SUCCESS;
          }
          #+end_src
    
   
* TODO [[https://zinascii.com/2014/a-posix-queue-implementation.html][A POSIX Queue Implementation]]                        :unix:posix:queue:
* TODO [[https://charity.wtf/2016/05/31/operational-best-practices-serverless/][Operational Best Practices #serverless]]          :operations:practices:
* DONE [[https://charity.wtf/2016/05/31/wtf-is-operations-serverless/][WTF is Operations? #serverless]]                            :operations:
  CLOSED: [2017-04-07 Fri 16:55]
  - What is operations?
    - constellation of org's tech skills, practices, cultural values around
      designing, building, maintaining systems, shipping, and solving problems
      with technology.
    - Ops teams aren't the sole keeper of reliability.
    - "Thinking about operational quality in terms of “a thing some other team is responsible for” is just generally not associated with great outcomes."
  - Core competencies of good ops engineers
    1. Scalability
    2. Resiliency
    3. Availability
    4. Maintainability
    5. Simplicity in complex systems
    6. Instrumentation and visibility
    7. Graceful degradation
  - Ops, historically speaking, attracted greater proportion
  - The BOFH stereotype is dead.  
  - "Some of the most creative cultural and technical changes in the technical landscape are being driven by the teams most identified with operations and developer tooling."
  - "You don’t make operational outcomes magically better by renaming the team “DevOps” or “SRE” or anything else."

* TODO [[https://pingcap.github.io/blog/2016/10/17/how-we-build-tidb/][How We Build TiDB]]                                         :db:distsys:
* TODO [[https://medium.com/@MaartenSikkema/using-dotnet-core-orleans-redux-and-websockets-to-build-a-scalable-realtime-back-end-cd0b65ec6b4d][Building a realtime server backend using the Orleans Actor system, Dotnet Core and Server-side Redux]] :realtime:orleans:

* DONE [[http://nchammas.com/writing/how-not-to-die-hard-with-hypothesis][Solving the Water Jug Problem from Die Hard 3 with TLA+ and Hypothesis]] :tla:propertybasedtesting:
  CLOSED: [2017-04-06 Thu 13:34]
  - Problem: Using only a 3 gallon jug and a 5 gallon jug, get me exactly 4 gallons of water.
  - There's a [[https://github.com/tlaplus/Examples/blob/master/specifications/DieHard/DieHard.tla][TLA+ spec]] for this already, but can it be solved with Hypothesis, the Python property based testing lib?
    - The answer is, yes. But, I'm not, and the author isn't sure if TLA+ / Hypothesis are equal in power. My guess is not, but maybe?
  - Exploits RuleBasedStateMachine to create Step Functions
    - and uses invariants that must be satisified
      e.g. small jug is between 0 and 3 gallons, big between 0 and 5
           big != 4.
    - THEN, then the invariant of big != 4 is *invalidated*, e.g. we have exactly 4 gallons, the test fails, and Hypothesis
      tells you the steps! 
    - This is almost exactly the opposite of what TLA+s' model checker does, but works almost exactly the same!


* DONE [[https://artkond.com/2017/03/23/pivoting-guide/][A Red Teamer's guide to pivoting]]                 :security:pentesting:
  CLOSED: [2017-04-03 Mon 23:22]
  - You've found an RCE in a web-app accessible from the internet, and have a shell.
    - SSH port forwarding: 
      ssh username@host -D 1080 # socks server on the local Intranet.
      ssh username@host -L 445:192.168.1.1:445 # 445 opened on attacker's side to 445 in Intranet
    - SSH can tunnel layer 3 traffic via established ssh channels. (need root on both machines)
      (PermitRootLogin yes, PermitTunnel yes)
      - ssh username@server -w any:any # create pair of tun devices
      - tunnels created, but not activated
        - ip addr add 1.1.1.2/32 peer 1.1.1.1 dev tun0 # client side
        - id addrs add 1.1.1.2/32 peer 1.1.1.2 dev tun0 # server side
        - echo 1 > /proc/sys/net/ipv4/ip_forward # enable NAT forwarding
        - iptables -t nat -A POSTROUTING -s 1.1.1.2 -o eth0 -j MASQUERADE
        - route add -net 10.0.0.0/16 gw 1.1.1.1 # default gateway for that network
    - 3proxy (https://github.com/z3APA3A/3proxy/releases)
      - can be used as socks proxy or port forwarder
      - general swiss army knife
    - rpivot: https://github.com/artkond/rpivot
      - traverses NAT connections. reverse socks proxy. works like ssh -D but in opposite direction.
  - On the internal network, limited connectivity
    - ICMP tunneling via [[http://code.gerade.org/hans/][hans]] (need root locally since raw sockets)
      - hans -v -f -s 1.1.1.1 -p P@ssw0rd # server side
      - hans -f -c <server ip> -p P@ssw0rd # client side
    - DNS tunneling
      - WAN traffic might be blocked, but can resolve external names.
      - If you have root, [[http://code.kryo.se/iodine/][iodine]] works almost like hans.
        - iodined -f -c -P P@ssw0rd 1.1.1.1 tunneldomain.com # server
        - iodone -f -P P@ssw0rd tunneldomain.com -r # client
        - Success yields direct visibility at 1.1.1.2.
        - Then, using compression:
          ssh user@1.1.1.2 -C -c blowfish-cbc,arcfour -o CompressionLevel=9 -D 1080
      - [[https://github.com/iagox86/dnscat2][Dnscat2]] doesn't require root.
    - Corporate HTTP proxy as way out.
      - Rpivot, [[http://cntlm.sourceforge.net/][Cntlm]], OpenVpn over HTTP proxy.
  - [[http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet][Reverse Shell Cheat Sheet]]
  - Upgrade from regular semi-interactive shell:
    =python -c 'import pty; pty.spawn("/bin/bash")'=
  - socat
  - [[https://github.com/creaktive/tsh][Tsh]]: small ssh-like backdoor with full-pty terminal.
* DONE [[https://stripe.com/blog/rate-limiters][Scaling your API with rate limiters]]                          :distsys:
  CLOSED: [2017-04-03 Mon 23:01]
  - Rate limiting can make your API more reliable when:
    - One of your users is responsible for a spike in traffic, but you need to stay up for others
    - Misbehaving scripts accidentially sending you lots of request
    - User sending lower priority stuff.
      (This implies that you have some sort of prioritization of requests)
    - Something wrong internally.
  - Stripe implements a few strategies to keep the API available for everyone
  - Not an option if spacing out requests isn't an option.
  - During incidents, shed load by dropping low priority requests.
  - 4 types used in production
    - Request rate limiter (e.g. N requests per second) -- Stripe has the ability to burst a bit.
    - Concurrent reuqests limiter (e.g. 20 requests at the same time). Helps with resource intensive requests
    - Fleet usage load shedder
      - Divide up traffic into critical (e.g. charges) and non-critical (list charges).
      - Reserve fraction of requests for charges
    - Worker utilization load shedding
      - Divide into Critical, POSTs, GETs, Test mode traffic
        - track workers: busy boxes will shed less critical requests
  - How to deploy?
    - Hook into middleware safely.
      e.g. what happens if redis goes down, or bugs?
    - Show good exceptions to your users 429 (Too Many Requests), 503 (Service Unavailable)
    - Control rods
    - Dark launch to simulate what would actually happen.

*** Further thoughts
    - Dark launches are helpful, but can't tell you exactly, since the potentially blocked traffic is still happening. This is similar to our auto scaling problem.
      
    

